if(player.x >= 400 || player.y <= 100 || player.x <= 100 || player.y >= 300) {
            console.log("method2");
            player.newPos();
            calculateDistance('draw2');
            
            if(player.x >= 400) {
                xcamMove = 0;
            }
            if(player.x <= 250) {
                xcamMove = 0;
            }
            if(player.y <= 100) {
                ycamMove = 0;
            }
            if(player.y >= 350) {
                ycamMove = 0;
            }
             /*gameArea.update2(xMovement2, yMovement2, xcamMove, ycamMove);*/
        }
        else {
            viewport.counter = 0;
            xcamMove = 0;
            ycamMove = 0;
            player.newPos();
            calculateDistance();
            gameArea.update();
        }
                draw2 : function(xMove, yMove, xcamMove, ycamMove) {
            if(this.counter == 0) {
                console.log(xbase, xMovement);
                console.log(ybase, yMovement);
                dwidth = xbase + xMovement;
                dheight = ybase + yMovement;
                ctx.fillRect(xbase, ybase, player.width, player.height);
                ctx.drawImage(world, xbase + xMovement + xcamMove, ybase + yMovement + ycamMove, 1000, 1000, 0, 0, 1000, 1000);
            }
            ctx = gameArea.context;
            ctx.save();
            ctx.clearRect(player.x + xMove, player.y + yMove, player.width, player.height);
            ctx.drawImage(world, xbase + xcamMove + xMovement, ybase + ycamMove + yMovement, 1000, 1000, 0, 0, 1000, 1000);
            ctx.translate(0 - xcamMove, 0 - ycamMove);
            ctx.fillRect(xbase + xcamMove, ybase + ycamMove, player.width, player.height);
            ctx.restore();
            if(ycamMove > 0) {
                ctx.fillStyle = "#0000A0";
                ctx.fillRect(xbase + xMove, ybase + ycamMove, player.width, player.height);
            }
            if(xcamMove > 0) {
                ctx.fillStyle = "#0000A0";
                ctx.fillRect(xbase + xcamMove, ybase + yMove, player.width, player.height);
            }
            else {
                ctx.fillStyle = "#0000A0";
                ctx.fillRect(xbase + xMove, ybase + yMove, player.width, player.height);
            }
            this.counter++;
        }
                obstacle2 : function(xMove = 0, xcamMove, yMove = 0, ycamMove) {
            for(var i = 0; i < obstaclesSize.length; i++) {
                  gameArea.updateObstacle2(obstaclesPos[i][0] + xMove, obstaclesPos[i][1] + yMove, i);
              }  
        },
        updateObstacle2: function (xpos,ypos, i)  {
            var diameterTop = ypos - (obstaclesSize[i][1] / 2);
            var diameterRight = xpos + (obstaclesSize[i][0] / 2);
            var diameterDown = ypos + (obstaclesSize[i][1] / 2);
            var diameterLeft = xpos - (obstaclesSize[i][0] / 2);
            obstaclesPos[i] = [xpos, ypos, diameterTop, diameterRight, diameterDown, diameterLeft];
            ctx = gameArea.context;
            ctx.fillStyle = "green";
            ctx.fillRect(xpos, ypos, obstaclesSize[i][0], obstaclesSize[i][1]);
        }
        update2 : function (xMove, yMove, xcamMove, ycamMove) {
            viewport.draw2(xMove, yMove, xcamMove, ycamMove);
            /*gameArea.obstacle2(xMove, xcamMove, yMove, ycamMove);*/
        },