<!DOCTYPE html>
<html>
    <head>
        <title> Canvas </title>
    <link rel="stylesheet" type="text/css" href="canvas.css" />
    <!--<meta name="viewport" content="width=device-width, initial-scale=1.0"/>-->
    <meta charset="utf-8" />
    <style>
    canvas {
        border:1px solid #d3d3d3;
    }
    </style>
    </head>
    <body onload="startGame();">
    <script>
    var world = new Image(2000, 1000);
    world.src = "maps.jpg";
    var player;
    var obstaclesPos = [];
    var obstaclesSize = [];
    var xMovement = 0;
    var yMovement = 0;
    var xMovement2 = 0;
    var yMovement2 = 0;
    var xbase = 350;
    var ybase = 200;
    var xcamMove = 0;
    var ycamMove = 0;
    var lastCalledTime;
    var fps;

    /*function requestAnimFrame() {
      if(!lastCalledTime) {
         lastCalledTime = Date.now();
         fps = 0;
         return;
      }
      delta = (perfomance.now() - lastCalledTime)/1000;
      lastCalledTime = performance.now();
      fps = math.floor(1/delta);
      console.log(fps);
    }*/
    var lastLoop = new Date();
    function gameLoop() {
        var thisLoop = new Date();
        var fps = 1000 / (thisLoop - lastLoop);
        lastLoop = thisLoop;
        console.log(fps);
    }


    function startGame() {
        gameArea.start();
        gameArea.world();
        loadObstacles();
        player = new component(50, 50, "white", xbase, ybase);
        player.first();
    }

    function loadObstacles() {
        var obstacle1 = new gameObstacle(200, 120, 50, 50);
        var obstacle2 = new gameObstacle(80, 70, 200, 50);
        var obstacle3 = new gameObstacle(-250, 200, 50, 200);
        var obstacle4 = new gameObstacle(300,255, 50,50);
        var obstacle5 = new gameObstacle(500, 200, 50, 200);
        /*var obstacle4 = new gameObstacle(500,255, 50, 300)*/
    }
    var gameArea = {
        canvas : document.createElement("canvas"),
        canvas2 : document.createElement("canvas"),
        start : function() {
            this.canvas.width = 700;
            this.canvas.height = 400;
            this.context = this.canvas.getContext("2d");
            document.body.insertBefore(this.canvas, document.body.childNodes[0]);
            setInterval(updateGameArea, 30);
            window.addEventListener('keydown', function (e) {
                gameArea.keys = (gameArea.keys || []);
                gameArea.keys[e.keyCode] = (e.type == "keydown");
            });
            window.addEventListener('keyup', function (e) {
                gameArea.keys[e.keyCode] = (e.type == "keydown");
            });
        },
        world : function() {
            this.context.drawImage(world, xbase, ybase, 1000, 1000, 0, 0, 1000, 1000);
        },
        update : function() {
            viewport.draw(player.x, player.y);
            gameArea.obstacle(player.speedX, player.speedY);
            this.context.fillStyle = "#0000A0";
            this.context.fillRect(xbase + player.speedX, ybase + player.speedY, player.width, player.height);
        },
        obstacle : function() {
            for(var i = 0; i < obstaclesSize.length; i++) {
                gameArea.updateObstacle(obstaclesPos[i][0], obstaclesPos[i][1], i);
            }
        },
        updateObstacle: function (xpos,ypos, i)  {
            var diameterTop = ypos - (obstaclesSize[i][1] / 2);
            var diameterRight = xpos + (obstaclesSize[i][0] / 2);
            var diameterDown = ypos + (obstaclesSize[i][1] / 2);
            var diameterLeft = xpos - (obstaclesSize[i][0] / 2);
            obstaclesPos[i] = [xpos, ypos, diameterTop, diameterRight, diameterDown, diameterLeft];
            ctx = gameArea.context;
            ctx.fillStyle = "green";
            ctx.fillRect(xpos - xMovement, ypos - yMovement, obstaclesSize[i][0], obstaclesSize[i][1]);
        },
    };

    var viewport = {
        dwidth: 0,
        dheight: 0,
        counter: 0,
        draw : function(playerX, playerY) {
            ctx = gameArea.context;
            ctx.save();
            ctx.clearRect(-xMovement, -yMovement, 500, 300);
            dwidth = xbase + xMovement;
            dheight = ybase + yMovement;
            ctx.drawImage(world, dwidth, dheight, 1000, 1000, 0, 0, 1000, 1000);
            ctx.translate(xbase + xMovement, ybase + yMovement);
            ctx.restore();
        },
    };

    function component(width, height, color, x, y) {
        this.gamearea = gameArea;
        this.width = width;
        this.height = height;
        this.speedX = 0;
        this.speedY = 0;
        this.x = x;
        this.y = y;
        this.top = "open";
        this.left = "open";
        this.down = "open";
        this.right = "open";
        this.diameterTop = this.y - 25;
        this.diameterRight = this.x + 25;
        this.diameterDown = this.y + 25;
        this.diameterLeft = this.x - 25;
        this.first = function() {
            ctx = gameArea.context;
            ctx.fillStyle = "#0000A0";
            ctx.fillRect(xbase, ybase, this.width, this.height);
        };
        this.newPos = function() {
            this.top = "open";
            this.left = "open";
            this.down = "open";
            this.right = "open";
            this.diameterTop = this.y - 25;
            this.diameterRight = this.x + 25;
            this.diameterDown = this.y + 25;
            this.diameterLeft = this.x - 25;
        };
    }

    function calculateDistance(call) {

        for(var i = 0; i < obstaclesPos.length; i++) {
           if(Math.abs(player.diameterDown - obstaclesPos[i][2]) <= 5 &&
              player.diameterRight >= obstaclesPos[i][5] &&
              player.diameterLeft <= obstaclesPos[i][3]) {
                player.down = "blocked";
                console.log("Down blocked");
           }
           if(Math.abs(player.diameterRight - obstaclesPos[i][5]) <= 5 &&
              player.diameterTop <= obstaclesPos[i][4] &&
              player.diameterDown >= obstaclesPos[i][2]) {
                player.right = "blocked";
                console.log("right blocked");
           }
           if(Math.abs(player.diameterTop - obstaclesPos[i][4]) <= 5 &&
              player.diameterRight >= obstaclesPos[i][5] &&
              player.diameterLeft <= obstaclesPos[i][3]) {
                player.top = "blocked";
                console.log("top blocked");
           }
           if(Math.abs(player.diameterLeft - obstaclesPos[i][3]) <= 5 &&
              player.diameterTop <= obstaclesPos[i][4] &&
              player.diameterDown >= obstaclesPos[i][2]) {
                player.left = "blocked";
                console.log("left blocked");
           }
        }

            if(gameArea.keys[37] && player.left == "blocked") {
                player.speedX = 0;
            }
            if (gameArea.keys[39] && player.right == "blocked") {
                player.speedX = 0;
            }
            if(gameArea.keys[40] && player.down == "blocked") {
                player.speedY = 0;
            }
            if(gameArea.keys[38] && player.top == "blocked") {
                player.speedY = 0;
            }
            player.x += player.speedX;
            player.y += player.speedY;
            console.log(player.speedX);
            console.log(player.speedY);
            if(call == 'draw2') {
                xMovement2 += player.speedX;
                yMovement2 += player.speedY;
                xcamMove += player.speedX;
                ycamMove += player.speedY;
            }
            else {
                xMovement += player.speedX;
                yMovement += player.speedY;
            }
    }

    function gameObstacle (x, y, width, height) {
        this.diameterTop = y - (height/2);
        this.diameterRight = x + (width/2);
        this.diameterDown = y + (height/2);
        this.diameterLeft = x - (width/2);
        ctx = gameArea.context;
        ctx.fillStyle = "green";
        ctx.fillRect(x, y, width, height);
        obstaclesPos.push([x, y, this.diameterTop, this.diameterRight, this.diameterDown, this.diameterLeft]);
        obstaclesSize.push([width, height]);
    }

    function updateGameArea() {
        player.speedX = 0;
        player.speedY = 0;
        if (gameArea.keys && gameArea.keys[37]) {player.speedX = -2; }
        if (gameArea.keys && gameArea.keys[39]) {player.speedX = 2; }
        if (gameArea.keys && gameArea.keys[38]) {player.speedY = -2; }
        if (gameArea.keys && gameArea.keys[40]) {player.speedY = 2; }
        console.log(player.x);
        console.log(player.y);

        player.newPos();
        if(player.x >= 700 || player.y <= -100 || player.x <= 100 || player.y >= 350) {
            console.log("method2");
            if(player.x >= 700) {
                player.right = "blocked";
            }
            if(player.x <= 100) {
                player.left = "blocked";
            }
            if(player.y <= 100) {
                player.top = "blocked";
            }
            if(player.y >= 350) {
                player.down = "blocked";
            }
             /*gameArea.update2(xMovement2, yMovement2, xcamMove, ycamMove);*/
        }
        calculateDistance();
        viewport.counter = 0;
        xcamMove = 0;
        ycamMove = 0;
        gameArea.update();
    }
    console.log(obstaclesPos);
    </script>
</body>
</html>
